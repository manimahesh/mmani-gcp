name: Build, Push, and Deploy to GKE

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}
  GKE_ZONE_OR_REGION: ${{ secrets.GKE_ZONE_OR_REGION }}
  GCR_HOSTNAME: us-west2-docker.pkg.dev
  IMAGE_NAME: hello-world-app
  DEPLOYMENT_NAME: hello-world-deployment

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # --- GCR Authentication and Image Pushing ---
      - id: 'auth'
        name: 'Authenticate to GCP'
        uses: 'google-github-actions/auth@v3'
        with:
            project_id: ${{ secrets.GCP_PROJECT_ID }}
            workload_identity_provider: ${{secrets.WORKLOAD_IDENTITY_PROVIDER}}
            service_account: '540198532097-compute@developer.gserviceaccount.com'

      - name: 'Set up GCR'
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: 'Authorize Docker to GCR'
        run: |
          gcloud auth configure-docker
          gcloud auth configure-docker us-west2-docker.pkg.dev

      - name: Build and Push Docker image to GCR
        id: build-image
        run: |
          echo "Image Name: $GCR_HOSTNAME/$PROJECT_ID/mmani-gcr-repo/$IMAGE_NAME:$GITHUB_SHA......"
          docker build -t $GCR_HOSTNAME/$PROJECT_ID/mmani-gcr-repo/$IMAGE_NAME:$GITHUB_SHA .
          docker push $GCR_HOSTNAME/$PROJECT_ID/mmani-gcr-repo/$IMAGE_NAME:$GITHUB_SHA
        
      # --- GKE Deployment ---
      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE_OR_REGION }}

      - name: Deploy to GKE
        run: |
          IMAGE_TAG=$GCR_HOSTNAME/$PROJECT_ID/$IMAGE_NAME:$GITHUB_SHA
          
          # Create and apply the Kubernetes deployment manifest inline
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.DEPLOYMENT_NAME }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: hello-world
            template:
              metadata:
                labels:
                  app: hello-world
              spec:
                containers:
                  - name: hello-world-container
                    image: $IMAGE_TAG
                    ports:
                      - containerPort: 8080
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: hello-world-service
          spec:
            type: LoadBalancer # Use LoadBalancer to expose externally
            selector:
              app: hello-world
            ports:
              - protocol: TCP
                port: 80
                targetPort: 8080
          EOF